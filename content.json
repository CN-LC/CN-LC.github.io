{"pages":[],"posts":[{"title":"二零二零年七月上每日一题","text":"因为一次开黑打击到我了决定改变嗯 剑指 Offer 09. 用两个栈实现队列难度简单 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 1234输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1] 示例 2： 1234输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 提示： 1 &lt;= values &lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 1234567891011121314151617181920212223242526class CQueue {public: stack&lt;int&gt;s1,s2; CQueue() { } void appendTail(int value) { s1.push(value); } int deleteHead() { if(s2.empty()){ while(!s1.empty()){ s2.push(s1.top()); s1.pop(); } } if(s2.empty()) return -1; else{ int res=s2.top(); s2.pop(); return res; } } }; 718. 最长重复子数组难度中等 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。 （子数组默认连续子序列默认不连续） 示例： 123456输入：A: [1,2,3,2,1]B: [3,2,1,4,7]输出：3解释：长度最长的公共子数组是 [3, 2, 1] 。 提示： 1 &lt;= len(A), len(B) &lt;= 1000 0 &lt;= A[i], B[i] &lt; 100 动态规划： 123456789101112131415161718class Solution {public: int res=-1; int dp[1000][1000]; int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) { for(int i=0;i&lt;A.size();i++){ for(int j=0;j&lt;B.size();j++){ if(A[i]==B[j]){ if(i-1&lt;0||j-1&lt;0) dp[i][j]=1; else dp[i][j]=dp[i-1][j-1]+1; } else dp[i][j]=0; res=max(res,dp[i][j]); } } return res; }}; 滑动窗口： 1234567891011121314151617181920212223242526272829303132class Solution {public: int find(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B,int addA,int addB,int len){ int ans=0; //检查每次滑动最长子数组 int k=0; for(int i=0;i&lt;len;i++){ if(A[i+addA]==B[i+addB]){ k++; } else k=0; ans=max(k,ans); } return ans; } int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) { int m=A.size(),n=B.size(); int res=0; for(int i=0;i&lt;m;i++){ //A不动B滑动 int len=min(m-i,n); int res1=find(A,B,i,0,len); res=max(res1,res); } for(int i=0;i&lt;n;i++){ ////B不动A滑动 int len=min(n-i,n); int res2=find(A,B,0,i,len); res=max(res2,res); } return res; }}; 378. 有序矩阵中第K小的元素难度中等 给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。 示例： 12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,返回 13。 提示：你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2。 暴力不推荐 学到了新语法 注意是vector push_back,加&amp;省时间。 12345678910111213class Solution {public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) { vector&lt;int&gt; rec; for (auto&amp; row : matrix) { for (auto it : row) { rec.push_back(it); } } sort(rec.begin(), rec.end()); return rec[k - 1]; }}; 归并排序法： priority_queue&lt;point, vector, greater&gt; que; 放在函数外面编译出错 没搞懂唉 注意本题利用小根堆 需要重载&gt;运算符，不能重载&lt;运算符！ 12345678910111213141516171819202122class Solution {public: struct point{ int val,x,y; bool operator&gt;(const point &amp;w) const{return val&gt;w.val;} }; int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) { priority_queue&lt;point, vector&lt;point&gt;, greater&lt;point&gt;&gt; que; int n=matrix.size(); for(int i=0;i&lt;n;i++){ que.push({matrix[i][0],i,0}); } for(int i=0;i&lt;k-1;i++){ int x=que.top().x; int y=que.top().y; que.pop(); if(y&lt;n-1){ que.push({matrix[x][y+1],x,y+1}); } } return que.top().val; }}; 二分答案（官方题解太妙了一定需要复习）！ 时间复杂度最低 12345678910111213141516171819202122232425262728293031323334353637lass Solution { public: bool check(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int mid, int k, int n) { int i = n - 1; //统计小于等于mid的个数 int j = 0; int num = 0; while (i &gt;= 0 &amp;&amp; j &lt; n) { if (matrix[i][j] &lt;= mid) { num += i + 1; j++; } else { i--; } } return num &gt;= k; } int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) { int n = matrix.size(); int left = matrix[0][0]; int right = matrix[n - 1][n - 1]; while (left &lt; right) { int mid = left + ((right - left) &gt;&gt; 1); //mid=(left+right)/2;也对； if (check(matrix, mid, k, n)) { right = mid; } else { left = mid + 1; } } return left; }};作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/you-xu-ju-zhen-zhong-di-kxiao-de-yuan-su-by-leetco/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 108. 将有序数组转换为二叉搜索树难度简单 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 由于题目给的是有序数组 所以可以二分+递归构造平衡二叉搜索树 每次取中间的数字保证了左右子树高度差不超过1 null在c++中实际为0 所以使用nullptr更加安全 搜索树：左孩子小于父节点，右孩子大于父节点，如此递归 ；中序遍历为一个升序序列 1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* buildtree(vector&lt;int&gt;&amp; nums,int left,int right){ if(left&gt;right) return nullptr; //注意这种情况的讨论 int mid=(right+left)&gt;&gt;1; TreeNode* root=new TreeNode(nums[mid]); root-&gt;left=buildtree(nums,left,mid-1); root-&gt;right=buildtree(nums,mid+1,right); return root; } TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) { return buildtree(nums,0,nums.size()-1); }};","link":"/2020/06/30/2020-06-30-%E4%BA%8C%E9%9B%B6%E4%BA%8C%E9%9B%B6%E5%B9%B4%E4%B8%83%E6%9C%88%E4%B8%8A%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/01/11/hello-world/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"}],"categories":[{"name":"leetcode每日一题","slug":"leetcode每日一题","link":"/categories/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]}